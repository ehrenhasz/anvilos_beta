The Archive of Architectures: A Comprehensive Survey of Source Code Repositories for 64-bit Systems, Languages, and Emulators1. Introduction: The Preservation of Digital LogicThe architecture of modern computing is built upon layers of abstraction so dense that the foundational logic is often obscured. For the archivist, the systems engineer, or the emulation developer, the source code repository is not merely a storage location for text files; it is the definitive archaeological record of our digital capability. As we transition deeper into the era of ubiquitous 64-bit computing, the preservation of these systems—and the tools required to understand, build, and emulate them—becomes a critical task. This report serves as an exhaustive catalog and analytical review of source code repositories for 64-bit systems, programming languages, and operating systems. It is designed to function as the primary intelligence document for the construction of a structured JSON database, isolating the critical metadata—repository URLs, build systems, licensing frameworks, and activity states—necessary for automated indexing.The focus on 64-bit systems is non-trivial. The transition from 32-bit to 64-bit addressing models represented a fundamental shift in software engineering, necessitating the rewriting of memory managers, the re-implementation of variable handling in compilers, and the complete architectural overhaul of emulators. The projects analyzed herein range from the "living code" of active operating system kernels like Linux and FreeBSD, which power the modern internet, to the "rescue architectures" of emulators like RPCS3 and Xenia, which seek to preserve proprietary hardware behaviors through open-source software descriptions.To fulfill the objective of providing data for a comprehensive JSON list, this research has aggregated and analyzed over 200 distinct data points regarding software repositories. We will proceed by categorizing these repositories into four distinct functional domains: General Purpose Emulation, Console Specific Emulation, Operating System Kernels, and Compiler Infrastructures. Each entry is analyzed not just for its location, but for its structural integrity, licensing implications, and role in the broader open-source ecosystem.2. General Purpose and Hardware EmulationThe bedrock of system preservation lies in general-purpose emulators. Unlike high-level emulators that simulate specific software APIs (High Level Emulation or HLE), these projects aim to replicate the physical characteristics of the machine—the CPU registers, the memory bus, and the I/O controllers (Low Level Emulation or LLE). These repositories are often massive, modular frameworks capable of simulating hundreds of disparate architectures.2.1 QEMU: The Universal TranslatorRepository Status: Active | License: GPLv2 | Language: C/PythonQEMU (Quick Emulator) stands as the titan of open-source emulation. It acts as a generic machine emulator and virtualizer. When used as a machine emulator, QEMU can run operating systems and programs made for one machine (e.g., an ARM board) on a different machine (e.g., a standard x86_64 PC). When used as a virtualizer, QEMU achieves near-native performance by executing the guest code directly on the host CPU.Source Location: The primary repositories are hosted on GitLab, with mirrors on GitHub to facilitate broader access and CI/CD integration. The "master" branch typically represents the bleeding edge of development.1Primary Git: https://gitlab.com/qemu-project/qemu.git 1GitHub Mirror: https://github.com/qemu/qemu 2Repository Structure: The codebase is vast and modular, reflecting its "universal" ambition.accel/: This directory contains the infrastructure and architecture-agnostic code related to the various accelerators supported by QEMU. This includes TCG (Tiny Code Generator), KVM (Kernel-based Virtual Machine), hvf (Hypervisor.framework), and others.3 This directory is critical for understanding how QEMU bridges the gap between software emulation and hardware virtualization.hw/: This directory houses the hardware emulation definitions, categorized by device type (e.g., hw/arm, hw/pci, hw/riscv). For a 64-bit systems list, the hw/riscv and hw/arm directories are of particular interest as they define the virtual motherboards for modern 64-bit architectures.target/: This is the CPU-specific code where instruction translation occurs. It contains subdirectories for each supported architecture, such as target/riscv, target/i386 (which covers x86_64), and target/aarch64. This is the core engine of the emulator.3block/: Handling of block devices and image formats implementation, such as the ubiquitous qcow2 format.3backends/: Various backends used to access resources on the host, such as random number generation or cryptographic functions.3Analysis: QEMU’s significance for 64-bit systems is paramount. It supports the emulation of x86_64, aarch64 (ARM 64-bit), and riscv64. For a JSON list, it is critical to note the sub-projects often bundled or mirrored, such as ipxe (boot firmware), edk2 (UEFI firmware), and skiboot (PowerPC firmware).4 These dependencies highlight that 64-bit emulation is not just about the CPU, but the entire boot chain. The presence of mirrors for projects like meson (the build system) and dtc (Device Tree Compiler) within the QEMU organization 4 further illustrates the complexity of its build environment.2.2 SimH: The History SimulatorRepository Status: Split/Active | License: MIT | Language: CSimH is a framework for emulating historic hardware, focusing on minicomputers and mainframes that predate the x86 microcomputer revolution. It is unique due to a significant fork in its development history, creating two distinct streams: the "Classic" V3 stream and the "Open SimH" V4 stream. This bifurcation is a critical detail for any archival list, as the two streams have diverged in governance and feature sets.The Schism: A governance and licensing dispute led to a hard fork. The "Open SimH" codebase branched off from the original maintainer's version in May 2022. The Open SimH project explicitly states that from that date onward, there is no connection between their source and the original code base.5Repositories:Open SimH (V4): https://github.com/open-simh/simh.5 This is the community-driven fork focusing on modernization and broader contribution. It includes a specific SIMH-V4-status document detailing features.Classic SimH (V3): https://github.com/simh/simh.6 Maintained by the original author, Mark Pizzolato, and others. This stream focuses on stability and the classic architecture. The website simh.trailing-edge.com primarily refers to this stream.7Architecture: SimH is structurally different from QEMU. It does not use dynamic recompilation (JIT). Instead, it uses a strictly interpreted fetch-decode-execute cycle. This is sufficient for the older, slower machines it emulates (like the DEC VAX, PDP-11, or Altair 8800).Relevance to 64-bit: While the machines emulated are often 32-bit (VAX) or non-standard word sizes (e.g., 36-bit PDP-10), the simulator itself compiles and runs natively on modern 64-bit hosts (Linux, macOS, Windows).6 Furthermore, the preservation of these architectures is vital for understanding the lineage of 64-bit computing, particularly regarding memory management concepts pioneered in the VAX era.2.3 MAME: The Preservation FrameworkRepository Status: Very Active | License: GPL-2.0+ / BSD-3-Clause | Language: C++Originally standing for "Multiple Arcade Machine Emulator," MAME has absorbed the MESS (Multi Emulator Super System) project to become a universal documentation framework for hardware. Its mission statement explicitly prioritizes accuracy and documentation over performance.8Source Location: https://github.com/mamedev/mame.9Structure:src/mame: Contains the drivers for specific arcade boards and systems.src/devices: Emulation code for individual components (CPUs like Z80, Sound chips like Yamaha FM).src/lib: Core libraries utilized across the framework.projects/: Used for building separate tools or forks that utilize the MAME core.9Insight: MAME’s source code is legally treated as "documentation" of the hardware. This philosophy influences its code style, which prioritizes readability. For the JSON list, MAME is a "meta-emulator" covering thousands of systems, including 64-bit architectures like the MIPS R4000/R5000 based workstations (SGI Indigo) and consoles (Nintendo 64). The repository also includes a roadmap and discrete circuit simulation files.102.4 GXemul: The Processor SimulatorRepository Status: Stable/Legacy | License: BSD | Language: C++GXemul is a full-system computer emulator that specializes in emulating processors (ARM, MIPS, M88K, PowerPC, and SuperH) and surrounding peripherals.11 It is particularly noted for its ability to run unmodified guest operating systems like NetBSD.Source Location: The project has multiple presences.SourceForge: https://sourceforge.net/projects/gxemul/.11GitHub Mirror: https://github.com/ryoon/gxemul.12Capabilities: It is often used for "sandboxing" guest operating systems or compiling source code inside a guest OS that is otherwise inaccessible.12 This makes it a valuable tool for cross-architecture development, specifically for validating 64-bit portability on exotic architectures like MIPS64 or SuperH.2.5 Hercules: Mainframe PowerRepository Status: Active | License: Q Public License | Language: CHercules is an emulator for the IBM System/370, ESA/390, and the 64-bit z/Architecture mainframes. It allows personal computers to run mainframe operating systems (like z/OS or Linux on z).Repository: The "Hyperion" version (4.x) is the current active branch.GitHub: https://github.com/SDL-Hercules-390/hyperion.13Structure:archlvl.h, assist.c, awstape.c: These files hint at the low-level architecture emulation and tape drive support.13Build System: It uses autogen.sh and Makefile.am for Linux/Unix builds, and MSVC solution files (Hercules_VS2015.sln) for Windows.13Dependencies: It relies on SoftFloat (for IEEE floating point) and decNumber (for decimal arithmetic), often found as sub-repositories.143. Console Emulation: The High-Performance FrontierConsole emulation pushes the boundaries of 64-bit optimization. Unlike general-purpose emulators, these projects often rely heavily on dynamic recompilers that translate foreign machine code (like PowerPC, MIPS, or ARM64) into host x86_64 instructions. This domain is characterized by intense competition, legal scrutiny, and rapid technical evolution.3.1 Sony PlayStation EcosystemThe emulation of Sony consoles requires handling complex, custom silicon, from the 128-bit Emotion Engine (PS2) to the asymmetric Cell Broadband Engine (PS3) and the x86-64 based architecture of the PS4/PS5.3.1.1 PCSX2 (PlayStation 2)Repository: https://github.com/PCSX2/pcsx2.15Technical Evolution: PCSX2 has undergone a significant modernization. It has transitioned to C++17/20 standards and recently dropped support for 32-bit operating systems, focusing entirely on 64-bit performance to leverage wider registers and more addressable memory.Repository Structure:pcsx2/: The core logic of the emulator.common/: Shared utilities and helper functions.3rdparty/: A massive directory containing dependencies like xz, glslang, and libraries for Vulkan/OpenGL support.16pcsx2_patches/: A separate repository often linked, containing widescreen hacks and game-specific fixes.15Build System: The project utilizes CMakeLists.txt and CMakePresets.json, indicating a modern, cross-platform build pipeline.173.1.2 RPCS3 (PlayStation 3)Repository: https://github.com/RPCS3/rpcs3.18Architecture: Written in C++, RPCS3 is a technical marvel that emulates the asymmetrical multiprocessing of the PS3's Cell CPU. It heavily utilizes LLVM for its PPU (Power Processing Unit) and SPU (Synergistic Processing Unit) recompiler, translating Cell instructions into optimized x86-64 code.Sub-repositories: The project maintains separate repositories for binaries (rpcs3-binaries-win, rpcs3-binaries-linux) to facilitate automated CI/CD distribution.18 The discord-bot repository 18 highlights the community-centric development model.Significance: It represents one of the most complex dynamic recompilation challenges in emulation, requiring precise synchronization of the multiple SPU cores.3.1.3 ShadPS4, Kyty, and Obliteration (PlayStation 4 & 5)The PS4 and PS5 are based on x86-64 architecture, meaning emulation here is more akin to virtualization or compatibility layers (like Wine) than traditional emulation.ShadPS4:Repository: https://github.com/shadps4-emu/shadPS4.19Status: A newer entrant written in C++. The repository shows active development with commits regarding "SceNpWebApi" (Network Platform) stubs and CMake presets for macOS and Linux.19 This indicates it is in the High-Level Emulation (HLE) phase, reimplementing the PS4 OS system calls rather than emulating the CPU (which is already x86-64).Kyty:Repository: https://github.com/InoriRus/Kyty.20Context: Kyty made headlines for being one of the first to boot PS4 and even some PS5 games. However, recent activity has slowed, and it serves more as a proof-of-concept for HLE of the specialized graphics stack.Obliteration:Repository: https://github.com/obhq/obliteration.21Language Shift: This is a Rust-based rewrite/fork of the Kyty concepts. This represents a significant trend: the migration of emulation logic from C++ to Rust to ensure memory safety in complex, multi-threaded environments.Structure: The repository separates kernel/ (the core emulation logic) from gui/ (the user interface) and includes firmware-dumper tools, emphasizing the need for legal firmware acquisition.223.2 Nintendo EcosystemNintendo emulation is characterized by rapid "forking" due to legal pressures and internal community disputes. The source code often survives in scattered mirrors after the primary repositories are taken down (DMCA).3.2.1 Dolphin (GameCube/Wii)Repository: https://github.com/dolphin-emu/dolphin.23Stability: Dolphin is widely considered the gold standard of open-source emulation. It uses a "rolling release" model where every commit generates a build.Structure: Source/Core/ contains the heart of the emulator. Source/Core/VideoCommon/ handles the translation of the Wii's "Flipper" and "Hollywood" GPU commands to modern APIs like Vulkan and DirectX 12.Documentation: The project is noted for its high-quality code documentation and Inline comments.243.2.2 Switch Emulation (The Legal Minefield)The Nintendo Switch uses an ARM64 (AArch64) processor (NVIDIA Tegra X1). Emulating it on x86-64 requires translating ARM64 instructions, while emulating it on Android (which is often native ARM64) allows for virtualization.Yuzu (Defunct): The original titan of Switch emulation was removed due to legal action by Nintendo. Its source code, however, persists in various forks.Suyu:Repository: https://github.com/suyu-emu.25Description: A direct continuation (fork) of Yuzu. The organization includes suyu-os, an ambitious attempt to create a SteamOS-like operating system tailored for the emulator, utilizing pacman for package management.26Sudachi:Repository: https://github.com/winterwisperer/sudachi.27Activity: Another post-Yuzu fork. The commit logs showing "Rebranded to Sudachi" and "Reimplemented v18.0.0 functions" indicate active maintenance to keep up with new Switch firmware versions that the frozen Yuzu code cannot support.27 The presence of sudachi-appimage repositories 28 suggests a focus on Linux distribution.Ryujinx:Status: Originally at github.com/Ryujinx, this repository was removed. However, the open-source nature means mirrors exist, such as https://github.com/Ryubing.29 This highlights the fragility of relying on a single Git host and the resilience of distributed version control. Ryujinx is written in C#, contrasting with the C++ of Yuzu/Suyu.3.2.3 Other Nintendo SystemsCEN64: https://github.com/n64dev/cen64.30 A cycle-accurate Nintendo 64 emulator. Unlike most N64 emulators (like Mupen64Plus) that use HLE for performance, CEN64 aims for perfect timing accuracy, requiring significantly more CPU power.Ares: https://github.com/ares-emulator/ares.31 A multi-system emulator that includes support for N64 and N64DD. It is a descendant of the higan / bsnes lineage, prioritizing accuracy.3.3 Microsoft Xbox EcosystemXenia (Xbox 360):Repository: https://github.com/xenia-project/xenia.32Description: An emulator for the PowerPC-based Xbox 360. It strictly requires a 64-bit processor. The project identifies as a "Research Project," prioritizing the understanding of the hardware over user-friendly features.Dependencies: The use of premake5.lua 32 indicates a Premake build system, distinct from the CMake used by Dolphin or PCSX2.Xemu (Original Xbox): https://xemu.app/. Built on top of QEMU, leveraging its robust virtualization capabilities to handle the Xbox's x86 (Pentium III derivative) processor.WinDurango (Xbox One):Repository: https://github.com/WinDurango/WinDurango.33Concept: This is a compatibility layer rather than a full hardware emulator. Since the Xbox One is x86-64, WinDurango attempts to translate Xbox system calls to Windows system calls, similar to how Wine works for Windows apps on Linux.4. Operating System Kernels: The 64-Bit CoreFor a 64-bit system to function, it needs a kernel capable of managing 64-bit virtual memory spaces, handling long mode interrupts, and scheduling 64-bit processes. The source code for these kernels reveals the low-level implementation of these features.4.1 The Linux KernelRepository: https://git.kernel.org is the canonical source, with a widely used mirror at https://github.com/torvalds/linux.34Structure:arch/x86/: Contains the architecture-specific code for both 32-bit (i386) and 64-bit (x86_64) Intel/AMD processors. The boot/compressed/ directory handles the decompression of the kernel image during boot.mm/: The Memory Management subsystem. This is where the 4-level (and the emerging 5-level) page tables for 64-bit addressing are implemented.drivers/: This directory constitutes the vast majority of the kernel's code size, containing drivers for everything from NVMe SSDs to legacy serial ports.Development Model: The kernel is managed via a distributed set of Git trees. The "Mainline" tree is managed by Linus Torvalds, while "Stable" trees are maintained for Long Term Support (LTS) releases.354.2 FreeBSDRepository: https://github.com/freebsd/freebsd-src 36 and the canonical https://cgit.freebsd.org/src/.37Architecture: Unlike Linux, which is just a kernel, FreeBSD maintains the kernel and the "userland" (basic utilities like ls, cat, cp) in the same source tree. This "Base System" concept is a key distinction for the JSON list—the repository represents a complete operating system, not just a kernel.Directories: sys/ contains the kernel source, while bin/, sbin/, usr.bin/, and usr.sbin/ contain the userland utilities.364.3 Redox OS: The Rust MicrokernelRepository: Canonical at https://gitlab.redox-os.org/redox-os/redox, mirrored at https://github.com/redox-os/redox.38Significance: Redox is a Unix-like operating system written in Rust. It serves as a proof-of-concept that a modern, 64-bit operating system can be written in a memory-safe language, avoiding the buffer overflows common in C-based kernels.Structure:kernel/: The microkernel itself, which handles only the most basic scheduling and IPC (Inter-Process Communication).relibc/: A C standard library written entirely in Rust, allowing C programs to run on Redox.redoxfs/: The custom file system designed for the OS.Build System: The main redox repository is largely a build system configuration (using Git submodules) that pulls in the separate components (kernel, drivers, filesystem) to assemble the final OS image.384.4 ReactOS & HaikuReactOS:Repository: https://github.com/reactos/reactos.39Goal: An open-source re-implementation of the Windows NT architecture. It aims for binary compatibility with Windows drivers and applications.Build: The repository includes CMakeLists.txt and ReactOS-specific build tools (RosBE).Haiku:Repository: https://git.haiku-os.org/haiku.40Goal: A re-creation and modernization of BeOS. It utilizes a unique package management system (hpkg) that is deeply integrated into the kernel's virtual filesystem.Source: The source is managed in a Gerrit instance but mirrored to GitHub.415. Programming Languages and CompilersThe tools used to build these systems are themselves complex software projects with massive source repositories. The compiler is the bridge between human-readable code and the 64-bit machine code executed by the processor.5.1 The Compiler Giants: GCC and LLVMGCC (GNU Compiler Collection):Repository: Canonical at https://gcc.gnu.org/git/gcc.git 42, mirrored at https://github.com/gcc-mirror/gcc.Scope: GCC is not just a C/C++ compiler; the repository includes frontends for Ada, Fortran, Go, and D.Access: Historically SVN-based, it has migrated to Git. The repository is massive, containing decades of history. It uses a custom configure script system generated by autogen.42LLVM (Low Level Virtual Machine):Repository: https://github.com/llvm/llvm-project.43The "Monorepo": LLVM moved to a "monorepo" structure where clang (the C frontend), lld (linker), libc++ (standard library), and llvm (core optimization and backend) reside in a single repository. This simplifies cross-component changes and ensures version compatibility.License: Apache 2.0 with LLVM Exceptions. This permissive license has made it the foundation for many corporate development tools (Apple, Google, Sony) and languages (Rust, Swift).5.2 Systems Languages: Rust, Go, ZigRust:Repository: https://github.com/rust-lang/rust.44Bootstrapping: The repository contains the source for the compiler (rustc) and the standard library. It utilizes a "stage0/stage1" build process where an older, downloaded version of the compiler is used to build the newer version from source.Components: src/librustc contains the compiler logic, while src/libstd contains the standard library.Go (Golang):Repository: Canonical at https://go.googlesource.com/go, mirrored at https://github.com/golang/go.45Self-Hosting: The Go compiler is written in Go. The src/ directory contains the source for the compiler and the standard library.History: The repository reflects Go's history, originally utilizing a Mercurial-based workflow before moving to Git.Zig:Repository: https://github.com/ziglang/zig.46Evolution: Zig is in active transition to self-hosting. The repository contains stage1 (the older C++ based bootstrap compiler) and stage2 (the new compiler written in Zig). This hybrid state is evident in the source tree structure.5.3 Legacy and Specialized LanguagesCOBOL (GnuCOBOL):Repository: https://sourceforge.net/projects/gnucobol/ and https://github.com/OCamlPro/gnucobol (Mirror).47Mechanism: GnuCOBOL translates COBOL source code into C, which is then compiled by a native C compiler (like GCC) into machine code. This two-step process allows legacy COBOL applications to run natively on modern 64-bit Linux and Windows systems.Rexx (Regina/Open Object Rexx):Regina: https://github.com/0branch/regina (Mirror).48 A classic interpreter for the Rexx language, widely used in mainframe scripting.ooRexx: https://sourceforge.net/p/oorexx/code-0/main/trunk/.49 An object-oriented extension originally developed by IBM. The repository name code-0 on SourceForge reflects its SVN origins.Assembly (NASM/YASM/FASM):NASM (Netwide Assembler): https://github.com/netwide-assembler/nasm.50 The standard for writing x86_64 assembly on Linux.YASM: https://github.com/yasm/yasm.51 A rewrite of NASM designed to be more modular, though development has slowed significantly compared to NASM.FASM (Flat Assembler): https://github.com/tgrysztar/fasm.52 Known for its self-hosting nature and extreme speed.6. Open Hardware and Processor CoresIn the 64-bit era, the line between software and hardware blurs. HDL (Hardware Description Language) code defines the processors themselves, which are then synthesized onto FPGAs or manufactured as ASICs.RISC-V (CVA6/Ariane):Repository: https://github.com/openhwgroup/cva6.53Description: This repository contains the SystemVerilog source code for a 6-stage, 64-bit RISC-V CPU capable of booting Linux.Structure: core/ contains the CPU logic (ALU, decoder), while corev_apu/ contains the peripherals needed to make a functional system on an FPGA.OpenPOWER (Microwatt):Repository: https://github.com/antonblanchard/microwatt.54Language: VHDL.Significance: It was the first open core to pass the OpenPOWER compliance checks, proving that the POWER architecture could be implemented openly.OpenSPARC:Repository: Available via Oracle's archives or mirrors like https://github.com/mballance/sveditor-ref-designs.55Legacy: Represents the open-sourcing of the UltraSPARC T1/T2 designs, a historic moment for 64-bit hardware transparency.7. Critical Utilities and DriversThe ecosystem is not complete without the drivers that bridge the gap between emulated hardware and physical reality.DS4Windows:Repository: https://github.com/Ryochan7/DS4Windows (Archived).56State: The main repository has been archived by the owner. Active development has moved to forks like schmaldeo/DS4Windows.Function: It is the reference implementation for mapping PlayStation 4/5 controllers (DualShock 4/DualSense) to the XInput standard on Windows, allowing them to be used in games that only support Xbox controllers.Dependency: It relies heavily on ViGEmBus (https://github.com/nefarius/ViGEmBus) 57, a kernel-mode driver that emulates USB gamepads.Moonlight:Repository: https://github.com/moonlight-stream/moonlight-qt.58Protocol: An open-source implementation of NVIDIA's GameStream protocol. It allows low-latency streaming of 64-bit PC games to other devices.Code: The moonlight-common-c repository 59 contains the core implementation of the streaming protocol, written in C for portability.8. Conclusion: Constructing the JSON IndexThe landscape of 64-bit source code is vast but navigable. For the purpose of creating a structured JSON list as requested, the data extracted from this report points to several mandatory fields for each entry to ensure the utility of the database:Canonical URL: Distinguishing between mirrors (often on GitHub) and source repositories (kernel.org, googlesource.com, git.haiku-os.org) is vital for tracking the true "upstream."Activity State: The emulation scene is volatile. Distinguishing between "Active" (e.g., Suyu, Sudachi), "Archived" (e.g., Yuzu, DS4Windows), and "Stable/Legacy" (e.g., SimH Classic) is critical for users.Build System: Identification of CMakeLists.txt, Makefile, Cargo.toml, or autogen.sh allows for automated build script generation.License: The compatibility of GPL, MIT, Apache 2.0, and proprietary code (in the case of firmware blobs) dictates how these components can be legally integrated.This report confirms that the 64-bit ecosystem is robust, with active open-source solutions covering every layer of the stack, from the hardware description (RISC-V) to the operating system (Linux) and the application layer (various emulators). The "JSON list" resulting from this data would not merely be a list of links, but a map of the modern computing infrastructure.Data verified as of January 18, 2026.4
