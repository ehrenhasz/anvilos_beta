BICAMERAL REQUEST FOR COMMENTS: RFC-0010 (REVISED)
# TITLE: PROTOCOL TELEPORTATION (SHARED MEMORY TRANSPORT)
# CLASSIFICATION: SOVEREIGN // INTERNAL BUS
# AUTHOR: EHREN (ARCHITECT) // AI MEAT (SYNTH)
# STATUS: RATIFIED
# TARGET: x86_64-bicameral-linux-musl // AlloyDB Omni

---

## 1. ABSTRACT
The Bicameral Runtime ("The Anvil") operates in a network-denied environment (`-DNO_NETWORK`). To access the AlloyDB Cortex (Long-term Memory/Vector Store), we bypass standard networking protocols entirely.

**Protocol Teleportation** establishes a "Transporter Room"â€”a high-speed, zero-copy bridge using POSIX Shared Memory (`shm_open`) and named semaphores. It allows data payloads to dematerialize from the Runtime and rematerialize inside the Database engine instantaneously.

---

## 2. SYSTEM ARCHITECTURE

### 2.1 THE TRANSPORTER BUFFER (`/dev/shm/bicameral_transport`)
A single, fixed-size RAM block (Default: 64MB) mapped into the address space of both the Runtime and the AlloyDB instance.

**Layout Structure:**
| OFFSET | COMPONENT | DESCRIPTION |
| :--- | :--- | :--- |
| `0x0000` | **HEADER** | Magic Bytes (`0xB1C4M3RL`), Version, State Flags |
| `0x0020` | **LOCK_FIELD** | Process-Shared Mutex (Spinlock) |
| `0x0040` | **PAD_A** | Materialization Pad (Runtime -> DB) |
| `0x8000` | **PAD_B** | Materialization Pad (DB -> Runtime) |

### 2.2 THE ACTORS
1. **The Away Team (Runtime):** The Python process using the `teleport` C-extension.
2. **The Chief O'Brien (AlloyDB):** A custom PostgreSQL Background Worker (`bgworker`) loaded via `shared_preload_libraries` that manages the buffer.

---

## 3. IMPLEMENTATION: THE POSTGRES EXTENSION (`pg_teleport`)

To allow AlloyDB to receive the "transported" data, we inject a custom C extension that monitors the buffer.

### 3.1 `pg_teleport_worker.c` (Background Worker)
This process starts when AlloyDB boots. It does not listen on a port. It creates the transporter lock on the shared memory segment.

```c
/* pg_teleport_worker.c - PSEUDOCODE CONCEPT */

void _PG_init(void) {
BackgroundWorker worker;
memset(&worker, 0, sizeof(worker));
worker.bgw_name = "Bicameral Transporter Chief";
worker.bgw_function_name = "teleport_main";
worker.bgw_flags = BGWORKER_SHMEM_ACCESS | BGWORKER_BACKEND_DATABASE_CONNECTION;
RegisterBackgroundWorker(&worker);
}

void teleport_main(Datum main_arg) {
/* 1. INITIALIZE TRANSPORTER ROOM (SHM) */
int shm_fd = shm_open("/bicameral_transport", O_RDWR, 0660);
void *map = mmap(0, SEGMENT_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, shm_fd, 0);

/* 2. OPEN SIGNAL FREQUENCY (Semaphore) */
sem_t *sem_energize = sem_open("/bicameral_energize", 0);

/* 3. CONNECT TO INTERNAL DB SPI */
BackgroundWorkerInitializeConnection("bicameral_db", "bicameral_user", 0);

while (!shutdown_requested) {
/* Wait for "Energize" command from Runtime */
sem_wait(sem_energize);

/* Materialize Pattern from PAD_A */
TransportPacket pkt = read_pad(map->pad_a);

/* Execute SQL / Vector Search */
StartTransactionCommand();
SPI_connect();

if (pkt.type == OP_VECTOR_SEARCH) {
/* Perform pgvector search via SPI */
int ret = SPI_execute("SELECT content FROM memories ORDER BY embedding <-> $1 LIMIT 1", ...);
/* Rematerialize result to PAD_B */
write_pad(map->pad_b, SPI_getvalue(...));
}

SPI_finish();
CommitTransactionCommand();

/* Signal Runtime that transport is complete */
sem_post(map->sem_arrival);
}
}
```
